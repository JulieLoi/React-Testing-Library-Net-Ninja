# Project
Starting Project
- Cloned the "Starter Project" Branch
https://github.com/harblaith7/React-Testing-Library-Net-Ninja

This project covers unit testing and integration testing for a React app.

# Test Notes
https://testing-library.com/docs/queries/about/
https://jestjs.io/docs/getting-started
https://jestjs.io/docs/expect

## <u>Types of Tests</u>
<table>
    <tr>
        <td>
            There are three types of tests in general:<br />
            * <b>Unit Tests</b>: tests a piece of code in isolation<br />
            * <b>Integration Tests</b>: tests multiple components that interact with each other<br />
            * <b>End-to-End Tests (E2E Tests)</b>: simulates what a user is going to do<br />
        </td>
        <td>
            <img src ="https://user-images.githubusercontent.com/113395605/217402653-b7e2c426-0671-4797-957e-3ae5e96fea74.PNG" 
                width="250px"
            />
        </td>
    </tr>
</table>


## <u>Test Structure</u>
The test block describes what is being tested and usually consists of the following:

<img src ="https://user-images.githubusercontent.com/113395605/217403583-759a940d-3935-4b47-b81f-ddc8cd298ab8.PNG" 
    width="500px"
/>

<table>
    <tr>
        <th>Test Block Example</th>
        <th>Test Block Description</th>
    </tr>
    <tr>
        <td><code>
            test('renders learn react link', () => {<br />
                render(<App />);<br />
                const linkElement = screen.getByText(/learn react/i);<br />
                expect(linkElement).toBeInTheDocument();<br />
            });
        </code></td>
        <td>
            This test block is often found in <code>"create-react-app"</code> that is generated by default. <br />
            It renders the <code>App</code> component and finds the <code>linkElement</code> it wants to interact with. <br />
            Then it simply asserts that the <code>linkElement</code> exists.
        </td>
    </tr>
</table>

## <u>Intro to Query Methods</u>
We shall focus more on the test block example, especially on the query method for the <code>screen</code>. 

<code>screen</code> has a bunch of query methods, which can be broken down as the following:
 * Single Match vs Multiple Match
    * getBy, findBy, queryBy: these query methods must match only one element (if 0 or 1+, error)
    * getByAll, findByAll, queryByAll: these query methods return an array of matched elements 
 * Difference between get, find, query:
    * get: not asynchronous, will return an error for no match (0)
    * find: asynchronous, will return an error for no match (0)
    * query: not asynchronous, will not return an error for no match (0)


<img src ="https://user-images.githubusercontent.com/113395605/217406893-d7806c69-ef7d-41ed-8c75-1d042a357dfa.PNG" 
    width="500px"
/>

### Test Block Example
<table>
    <tr>
        <th>Test Block Example</th>
        <th>Screen Query Method</th>
    </tr>
    <tr>
        <td><code>
            test('renders learn react link', () => {<br />
                render(<App />);<br />
                const linkElement = screen.getByText(/learn react/i);<br />
                expect(linkElement).toBeInTheDocument();<br />
            });
        </code></td>
        <td>
            In this test block, we use the <code>getByText()</code> to get an element, which we suspect to be a <code>linkElement</code>.<br />
        </td>
    </tr>
</table>

## <u>Priority</u>
Now that we have discussed all of the prefixes for the query method, let us discuss the attribute portion.

In testing, we want to mimick user actions as much as possible in our tests.

<img src ="https://user-images.githubusercontent.com/113395605/217409161-a9542867-77d3-4284-85fe-8192e3a004d0.PNG" 
    width="500px"
/>

### Top Priority
As seen from the chart above, we want to use the query methods for components that can be accessed by everyone, meaning the component is exposed in the accessibility tree.:
 * [getByRole](https://testing-library.com/docs/queries/byrole/): Used to query every element that is exposed in the accessibility tree
 * [getByLabelText](https://testing-library.com/docs/queries/bylabeltext): This method is really good for form fields
 * [getByPlaceholderText](https://testing-library.com/docs/queries/byplaceholdertext): Alternative (other resort) for getByLabelText
 * [getByText](https://testing-library.com/docs/queries/bytext): Outside of forms, text content is the main way users find elements. This method can be used to find non-interactive elements (like divs, spans, and paragraphs).


### Middle Priority
 If we cannot get a component by using a query method for a component that can be accessed by everyone, we use semantic queries, which is not always visible to the user, but is visible to the <code>screen</code> itself:
 * [getByAltText](https://testing-library.com/docs/queries/byalttext): If your element is one which supports alt text (img, area, input, and any custom element), then you can use this to find that element.
 * [getByTitle](https://testing-library.com/docs/queries/bytitle): The title attribute is not consistently read by screenreaders, and is not visible by default for sighted users.

### Bottom Priority
The last priority is a Test ID (<code>data-test-id</code>), which is never seen by the user. It is the last resort if the screen cannot find the element.
 * [getByTestId](https://testing-library.com/docs/queries/bytestid): The user cannot see (or hear) these, so this is only recommended for cases where you can't match by role or text or it doesn't make sense (e.g. the text is dynamic).

## <u>Assertions</u> ([Link](https://jestjs.io/docs/expect))
Assertions from Jest test a component's element that has been retrieved (and maybe interacted with). It "expects" something from this element, which has many different assertion matchers, such as some of the following:
 * [Common Matchers](https://jestjs.io/docs/using-matchers#common-matchers)
    * toBe: the simplest way to test a value is with exact equality of objects.
    * toEqual: tests equality of the fields/values of objects/arrays (ignores undefined).
    * toStrictEqual: tests equality of the fields/values of objects/arrays (includes undefined, preferred).
 * [Truthiness](https://jestjs.io/docs/using-matchers#truthiness)
    * toBeNull: matches only null
    * toBeUndefined: matches only undefined
    * toBeDefined: is the opposite of toBeUndefined
    * toBeTruthy: matches anything that an if statement treats as true
    * toBeFalsy: matches anything that an if statement treats as false
 * [Numbers](https://jestjs.io/docs/using-matchers#numbers)
    * toBe/toEqual: equivalent matchers for numbers
    * toBeCloseTo: floating point number to ignore some minor rounding error (alternative for toBe/toEqual)
    * toBeGreaterThan: tests that number is greater than
    * toBeGreaterThanOrEqual: tests that number is greater than or equal
    * toBeLessThan: tests that number is less than
    * toBeLessThanOrEqual: tests that number is less than or equal
 * [String](https://jestjs.io/docs/using-matchers#strings)
    * toMatch: checks strings against regular expressions (regex)
 * [Arrays and Iterables](https://jestjs.io/docs/using-matchers#arrays-and-iterables)
    * toContain: check if an array or iterable contains a particular item
 * [Exceptions](https://jestjs.io/docs/using-matchers#exceptions)
    * toThrow: test whether a particular function throws an error when it's called


You can also test for the opposite of a matcher using <code>not</code>.

<table>
    <tr>
        <th>Assertion Code</th>
        <th>Assertion Description</th>
    </tr>
    <tr>
        <td><code>
                expect(element).toBeInTheDocument();<br />
                expect(element).not.toBeInTheDocument();<br />
        </code></td>
        <td>
            In general, in this code, <code>expect(element)</code> returns an "expectation" object. You typically won't do much with these expectation objects except call matchers on them.<br />
            The first line of code checks that the <code>element</code> is in the document.<br />
            The second line of code checks that the <code>element</code> is in the document using the <code>not</code>.
        </td>
    </tr>
</table>

## <u>Fire Events vs User Events</u>
Most projects have a few use cases for `fireEvent`, but the majority of the time you should probably use @testing-library/user-event.

`fireEvent` is a lightweight wrapper around the browser's low-level `dispatchEvent` API, which allows developers to trigger any event on any element.

`user-event` is a companion library for Testing Library that simulates user interactions by dispatching the events that would happen if the interaction took place in a browser.

The problem with `fireEvent` is that the browser usually does more than just trigger one event for one interaction. For example, when a user types into a text box, the element has to be focused, and then keyboard and input events are fired and the selection and value on the element are manipulated as they type.

The solution is `user-event`, which allows you to describe a user interaction instead of a concrete event. It adds visibility and interactability checks along the way and manipulates the DOM just like a user interaction in the browser would. 
 - It also factors in that the browser e.g. wouldn't let a user click a hidden element or type in a disabled text box.


## <u>Fire Events</u> ([Link](https://testing-library.com/docs/dom-testing-library/api-events))
`fireEvent` dispatchs DOM events.

## <u>User Events</u> ([Link](https://testing-library.com/docs/user-event/intro))
`user-event` simulates full interactions, which may fire multiple events and do additional checks along the way.


